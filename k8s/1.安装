#!/bin/bash
# 设置时区
timedatactl set-timezone Asia/Shanghai

# 关闭swap
swapoff -a

# 修改主机名
hostnamectl set-hostname test2

# 安装ipvs
yum install -y ipvsadm

# 开启路由转发
cat <<EOF >> /etc/sysctl.conf
net.ipv4.ip_forward = 1
EOF
sysctl -p 

# 加载bridge
yum install -y epel-release # fedora的专属包 
yum install -y bridge-utils # 提供了管理网络桥接（network bridging）功能的工具，主要用于配置和管理以太网桥。以太网桥允许多个网络接口（通常是虚拟网络接口）相互通信，好比一台虚拟交换机，使得不同的网络可以在二层协议（数据链路层）上互通。
modprobe br_netfilter # 是用于加载 Linux 内核模块 br_netfilter 的命令，在 Kubernetes 或 Docker 等容器环境中，通常需要启用 br_netfilter 模块来确保网络流量能够正确通过防火墙规则。加载此模块后，数据包就可以在网络桥上进行 NAT 转发和过滤。
cat >> /etc/modules-load.d/k8s.conf << EOF
br_netfilter
EOF
# 要确保系统重启后该模块仍然加载，可以将 br_netfilter 添加到 /etc/modules-load.d/ 中
cat  >> /etc/sysctl.conf <<EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sysctl -p

# 添加docker-ce源并安装
dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/fedora/docker-ce.repo
yum update
yum install -y docker-ce docker-compose #docker-ce-cli containerd.io
# "data-root": "", 切换docker的路径  cat <<EOF>> 这里是文件 EOF 也可以用
cat >> /etc/docker/daemon.json <<EOF
{
  "default-ipc-mode": "shareable",
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts": {
     "max-size": "100m",
     "max-file": "100"
  },
  "insecure-registries": ["control-server.com"],
  "registry-mirrors": ["https://kfp63jaj.mirror.aliyuncs.com"]
}
EOF

mkdir -p /etc/systemd/system/docker.service.d
systemctl daemon-reload && systemctl restart docker && systemctl enable docker

# 安装cri-docker，配合k8s
wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.9/cri-dockerd-0.3.9.amd64.tgz
tar -xf cri-dockerd-0.3.9.amd64.tgz
cp cri-dockerd/cri-dockerd /usr/bin/
chmod +x /usr/bin/cri-dockerd

# 配置cri-docker的服务
cat  >> /usr/lib/systemd/system/cri-docker.service <<EOF
[Unit]
Description=cri interface for docker app container engine
Documentation=https://docs.mirantis.com
After=network-online.target firewalld.service docker.service
Wants=network-online.target
Requires=cri-docker.socket
[Service]
Type=notify
ExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.10
ExecReload=/bin/kill -s HUP $MAINPID
TimeoutSec=0
RestartSec=2
Restart=always
StartLimitBurst=3
StartLimitInterval=60s
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
Delegate=yes
Killmode=process
[Install]
WantedBy=multi-user.target
EOF

cat  >> /usr/lib/systemd/system/cri-docker.socket  <<EOF
[Unit]
Description=cri docker socket for the api 
Partof=cri-docker.service
[Socket]
ListenStream=%t/cri-dockerd.sock
SocketMode=0600
SocketUser=root
SocketGroup=docker
[Install]
WantedBy=sockets.target
EOF

# 启动cri-docker 服务
systemctl daemon-reload
systemctl enable cri-docker
systemctl start cri-docker
systemctl is-active cri-docker

# 安装kubeadm 源
cat <<EOF | tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.31/rpm/
enabled=1
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.31/rpm/repodata/repomd.xml.key
EOF
setenforce 0
yum install -y kubelet kubeadm kubectl
systemctl enable kubelet && systemctl start kubelet


cat >> /etc/hosts << EOF
10.10.10.13 test2
10.10.10.14 test3
10.10.10.15 test4
EOF


# 这里不用执行
cat  >> /etc/sysctl.conf <<EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_nonlocal_bind = 1
net.ipv4.ip_forward = 1
vm.swappiness=0
EOF


# 初始化

kubeadm init \
        --apiserver-advertise-address=10.10.10.2 \
        --image-repository registry.aliyuncs.com/google_containers \
        --kubernetes-version 1.31.1 \
        --service-cidr=10.20.0.0/12 \
        --pod-network-cidr=10.244.0.0/16 \
        --ignore-preflight-errors=all \
        --cri-socket unix:///var/run/cri-dockerd.sock
# 初始化
kubeadm reset --cri-socket unix:///var/run/cri-dockerd.sock
root: U4508KWt
user: qtCc3jOI

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

# 假如k8s集群
kubeadm join 10.10.10.2:6443 --token gcb3qm.w570ht2nzyhtwk98 \
	--discovery-token-ca-cert-hash sha256:613aefcc8cb5aecd9aaa9bd0158e13e9c8446e48bd09e3eeaf44972acf723046\
  --cri-socket unix:///var/run/cri-dockerd.sock

# 下载calico-typha.yml文件，在GitHub直接下载也行
https://docs.tigera.io/calico/latest/getting-started/kubernetes/self-managed-onprem/onpremises#install-calico-with-kubernetes-api-datastore-more-than-50-nodes


docker load < calico-typha-master 
docker load < calico-kube-controllers-master  
docker load < calico-cni-master 
docker load < calico-node-master 



# 启动错误的配置文件，导致启动了错误的pod，需要删除
kubectl delete pod calico-kube-controllers-7bcf789c97-j9gvj -n kube-system --grace-period=0 --force
# kubectl delete pod：表示要删除一个 Pod。
# calico-kube-controllers-7bcf789c97-j9gvj：这是要删除的 Pod 的名称。
# -n kube-system：指定命名空间为 kube-system，因为这个 Pod 在该命名空间下。
# --grace-period=0：设置优雅终止的时间为 0 秒，即不等待 Pod 的正常终止过程。
# --force：强制删除 Pod，即使它处于 Terminating 状态。

# 发现由于ikuai启动失败，导致pod的某个失败，查看一下描述
kubectl describe pod kube-proxy-lplcl -n kube-system

# 经过检查发现镜像存在，是ikuai的问题，只能把这个pod删掉,删掉后发现可以使用了
kubectl delete pod kube-proxy-lplcl -n kube-system
